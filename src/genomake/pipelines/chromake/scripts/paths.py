"""
The paths module of chromake contains functions to identify the inputs and the files generated by the chromake pipeline.

"""
from pathlib import Path
import re


def get_all_fastq_related_paths(cfg: dict, mode: str) -> list:
    """
    Get the path to the files generated by the pipeline for the samples of all sequencing and projects.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    mode: str
        String representing the files to get. Accepted values are:
            - sequencing (raw fastq)
            - multiqc_raw (multiqc report regrouping the fastqc of the raw fastq files)
            - cutadapt (fastq after adapter trimming)
            - fastqc_trimmed (fastqc reports after the adapter trimming)
            - multiqc_trimmed (multiqc report after adapter trimming)
            - bam (bam files after alignment with bowtie2)
            - bam_filtered (bam files after filtering the non-standard chromosomes)
            - bedgraph (bedGrapg files generated by HOMER for UCSC visualisation)
    
    Returns
    -------
    list
        A list of file paths.
    """
    res = []
    for sequencing_name, sequencing_data in cfg["SEQUENCING"].items():
        base = Path(sequencing_data["PATH"])
        if mode == "sequencing":
            res.append(base)
        elif mode == "fastq_raw":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                res.append(base / sample["R1"])
                res.append(base / sample["R2"])
            if "INPUT" in sequencing_data:
                for inp in sequencing_data.get("INPUT", {}).values():
                    res.append(base / inp["R1"])
                    res.append(base / inp["R2"])
        elif mode == "fastqc_raw":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in sequencing_data:
                for inp in sequencing_data.get("INPUT", {}).values():
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R1"]).name))
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R2"]).name))
        elif mode == "multiqc_raw":
            res.append(base / "QC/MULTIQC/RAW/multiqc_report.html")
        elif mode == "cutadapt":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                res.append(base / "TRIMMED" / Path(sample["R1"]).name)
                res.append(base / "TRIMMED" / Path(sample["R2"]).name)
            if "INPUT" in sequencing_data:
                for inp in sequencing_data.get("INPUT", {}).values():
                    res.append(base / "TRIMMED" / Path(inp["R1"]).name)
                    res.append(base / "TRIMMED" / Path(inp["R2"]).name)
        elif mode == "fastqc_trimmed":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in sequencing_data:
                for inp in sequencing_data.get("INPUT", {}).values():
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R1"]).name))
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R2"]).name))
        elif mode == "multiqc_trimmed":
            res.append(base / "QC/MULTIQC/TRIMMED/multiqc_report.html")
        elif mode == "bam":
            for sample_name, sample_data in sequencing_data["SAMPLES"].items():
                res.append(base / "BAM" / (sample_name + ".bam"))
            if "INPUT" in sequencing_data:
                for input_name, input_data in sequencing_data["INPUT"].items():
                    res.append(base / "BAM" / (input_name + ".bam"))
        elif mode == "bam_filtered":
            for sample_name, sample_data in sequencing_data["SAMPLES"].items():
                res.append(base / "BAM" / (sample_name + "_filtered.bam"))
            if "INPUT" in sequencing_data:
                for input_name, input_data in sequencing_data["INPUT"].items():
                    res.append(base / "BAM" / (input_name + "_filtered.bam"))
        elif mode == "bedgraph":
            for sample_name, sample_data in sequencing_data["SAMPLES"].items():
                res.append(base / "HOMER" / (sample_name + "_UCSC_track.bedGraph"))
            if "INPUT" in sequencing_data:
                for input_name, input_data in sequencing_data["INPUT"].items():
                    res.append(base / "HOMER" / (input_name + "_UCSC_track.bedGraph"))  
        else:
            print(f"There is an error, chromake.scripts.path.get_path dont recognize the {mode} mode!")      
    return res
        
def get_sequencing_fastq_related_paths(cfg: dict,
                                       sequencing_name: str,
                                       mode: str) -> list:
    """
    Get the path to the files generated by the pipeline for the samples of a specific sequencing.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    sequencing_name: str
        String representing the name of the sequencing
    
    mode: str
        String representing the files to get. Accepted values are:
            - sequencing (raw fastq)
            - multiqc_raw (multiqc report regrouping the fastqc of the raw fastq files)
            - cutadapt (fastq after adapter trimming)
            - fastqc_trimmed (fastqc reports after the adapter trimming)
            - multiqc_trimmed (multiqc report after adapter trimming)
            - bam (bam files after alignment with bowtie2)
            - bam_filtered (bam files after filtering the non-standard chromosomes)
    
    Returns
    -------
    list
        A list of all file paths.
    """
    res = []
    if sequencing_name in cfg["SEQUENCING"].keys():
        base = Path(cfg["SEQUENCING"][sequencing_name]["PATH"])
        if mode == "sequencing":
            res.append(base)
        elif mode == "fastq_raw":
            for sample in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                res.append(base / sample["R1"])
                res.append(base / sample["R2"])
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for inp in cfg["SEQUENCING"][sequencing_name].get("INPUT", {}).values():
                    res.append(base / inp["R1"])
                    res.append(base / inp["R2"])
        elif mode == "fastqc_raw":
            for sample in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for inp in cfg["SEQUENCING"][sequencing_name].get("INPUT", {}).values():
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R1"]).name))
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R2"]).name))
        elif mode == "multiqc_raw":
            res.append(base / "QC/MULTIQC/RAW/multiqc_report.html")
        
        elif mode == "cutadapt":
            for sample in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                res.append(base / "TRIMMED" / Path(sample["R1"]).name)
                res.append(base / "TRIMMED" / Path(sample["R2"]).name)
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for inp in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                    res.append(base / "TRIMMED" / Path(inp["R1"]).name)
                    res.append(base / "TRIMMED" / Path(inp["R2"]).name)
        elif mode == "fastqc_trimmed":
            for sample in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for inp in cfg["SEQUENCING"][sequencing_name].get("SAMPLES", {}).values():
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R1"]).name))
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R2"]).name))
        elif mode == "multiqc_trimmed":
            res.append(base / "QC/MULTIQC/TRIMMED/multiqc_report.html")
        elif mode == "bam":
            for sample_name, sample_data in cfg["SEQUENCING"][sequencing_name]["SAMPLES"].items():
                res.append(base / "BAM" / (sample_name + ".bam"))
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for input_name, sample_data in cfg["SEQUENCING"][sequencing_name]["INPUT"].items():
                    res.append(base / "BAM" / (input_name + ".bam"))
        elif mode == "bam_filtered":
            for sample_name, sample_data in cfg["SEQUENCING"][sequencing_name]["SAMPLES"].items():
                res.append(base / "BAM" / (sample_name + "_filtered.bam"))
            if "INPUT" in cfg["SEQUENCING"][sequencing_name]:
                for input_name, input_data in cfg["SEQUENCING"][sequencing_name]["SAMPLES"].items():
                    res.append(base / "BAM" / (input_name + "_filtered.bam"))
    else:
        print(f"There is an error, the configuration file don't contains a {sequencing_name} project!")
    return res


