"""
The paths module of chromake contains functions to identify the inputs and the files generated by the chromake pipeline.

"""
from pathlib import Path
import re


def get_all_sequencings_related_paths(cfg: dict, mode: str) -> list:
    """
    Get the path to the files generated by the pipeline for the samples of all sequencings and projects.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    mode: str
        String representing the files to get. Accepted values are:
            - sequencing (raw fastq)
            - multiqc_raw (multiqc report regrouping the fastqc of the raw fastq files)
            - cutadapt (fastq after adapter trimming)
            - fastqc_trimmed (fastqc reports after the adapter trimming)
            - multiqc_trimmed (multiqc report after adapter trimming)
            - bam (bam files after alignment with bowtie2)
            - bam_filtered_coord (bam files after filtering the non-standard chromosomes and sorted by coordinate)
            - bam_filtered_name (bam files after filtering the non-standard chromosomes and sorted by name)
            - bedgraph (bedGrapg files generated by HOMER for UCSC visualisation)
    
    Returns
    -------
    :
        A list of file paths.
    """
    res = []
    for sequencing_name, sequencing_data in cfg["SEQUENCINGS"].items():
        base = Path(sequencing_data["PATH"])
        if mode == "SEQUENCINGS":
            res.append(base)
        elif mode == "fastq_raw":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / sample["R1"])
                if sample["R2"]:
                    res.append(base / sample["R2"])
            if "INPUT" in sequencing_data:
                for sample in sequencing_data.get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / sample["R1"])
                    if sample["R2"]:
                        res.append(base / sample["R2"])
        elif mode == "fastqc_raw":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                if sample["R2"]:
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in sequencing_data:
                for sample in sequencing_data.get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                    if sample["R2"]:
                        res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
        elif mode == "multiqc_raw":
            res.append(base / "QC/MULTIQC/Raw_fastq.html")
        elif mode == "multiqc_trimmed":
            res.append(base / "QC/MULTIQC//Trimmed_fastq.html")
        elif mode == "multiqc_bam":
            res.append(base / "QC/MULTIQC/Bam_report.html")
        elif mode == "cutadapt":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "TRIMMED" / Path(sample["R1"]).name)
                if sample["R2"]:
                    res.append(base / "TRIMMED" / Path(sample["R2"]).name)
            if "INPUT" in sequencing_data:
                for sample in sequencing_data.get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / "TRIMMED" / Path(sample["R1"]).name)
                    if sample["R2"]:
                        res.append(base / "TRIMMED" / Path(sample["R2"]).name)
        elif mode == "fastqc_trimmed":
            for sample in sequencing_data.get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                if sample["R2"]:
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in sequencing_data:
                for sample in sequencing_data.get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                    if sample["R2"]:
                        res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
        elif mode == "bam":
            for sample_name in sequencing_data["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + ".bam"))
            if "INPUT" in sequencing_data:
                for sample_name in sequencing_data["INPUT"].keys():
                    res.append(base / "BAM" / (sample_name + ".bam"))
        elif mode == "bam_filtered_coord":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + "_filtered.coordsort.bam"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "BAM" / (sample_name + "_filtered.coordsort.bam"))
        elif mode == "bam_filtered_name":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + "_filtered.namesort.bam"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "BAM" / (sample_name + "_filtered.namesort.bam"))
        elif mode == "bedgraph":
            for sample_name in sequencing_data["SAMPLES"].keys():
                res.append(base / "BEDGRAPH" / (sample_name + "_UCSC_track.bedGraph"))
            if "INPUT" in sequencing_data:
                for sample_name in sequencing_data["INPUT"].keys():
                    res.append(base / "BEDGRAPH" / (sample_name + "_UCSC_track.bedGraph"))  
        elif mode == "bed":
            for sample_name in sequencing_data["SAMPLES"].keys():
                res.append(base / "BED" / (sample_name + ".bed"))
            if "INPUT" in sequencing_data:
                for sample_name in sequencing_data["INPUT"].keys():
                    res.append(base / "BED" / (sample_name + ".bed"))
        elif mode == "bed_sorted":
            for sample_name in sequencing_data["SAMPLES"].keys():
                res.append(base / "BED" / (sample_name + "_sorted.bed"))
            if "INPUT" in sequencing_data:
                for sample_name in sequencing_data["INPUT"].keys():
                    res.append(base / "BED" / (sample_name + "_sorted.bed"))
        else:
            print(f"There is an error, chromake.scripts.path.get_path dont recognize the {mode} mode!")      
    return res
        
def get_sequencings_related_paths(cfg: dict,
                                       sequencing_name: str,
                                       mode: str) -> list:
    """
    Get the path to the files generated by the pipeline for the samples of a specific sequencing.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    sequencing_name: str
        String representing the name of the sequencing
    
    mode: str
        String representing the files to get. Accepted values are:
            - sequencing (raw fastq)
            - multiqc_raw (multiqc report regrouping the fastqc of the raw fastq files)
            - cutadapt (fastq after adapter trimming)
            - fastqc_trimmed (fastqc reports after the adapter trimming)
            - multiqc_trimmed (multiqc report after adapter trimming)
            - bam (bam files after alignment with bowtie2)
            - bam_filtered (bam files after filtering the non-standard chromosomes)
            - flagstat (output of samtools flagstat on the bam files)
            - stats (output of samtools stats on the bam files)
            - multiqc_stats (multiqc on the folder containing the stats output)
    
    Returns
    -------
    :
        A list of all file paths.
    """
    res = []
    if sequencing_name in cfg["SEQUENCINGS"].keys():
        base = Path(cfg["SEQUENCINGS"][sequencing_name]["PATH"])
        if mode == "SEQUENCINGS":
            res.append(base)
        elif mode == "fastq_raw":
            for sample in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / sample["R1"])
                if sample["R2"]:
                    res.append(base / sample["R2"])
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample in cfg["SEQUENCINGS"][sequencing_name].get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / sample["R1"])
                    if sample["R2"]:
                        res.append(base / sample["R2"])
        elif mode == "fastqc_raw":
            for sample in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                if sample["R2"]:
                    res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample in cfg["SEQUENCINGS"][sequencing_name].get("INPUT", {}).values():
                    if sample["R1"]:
                        res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                    if sample["R2"]:
                        res.append(base / "QC/FASTQC/RAW" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
        elif mode == "multiqc_raw":
            res.append(base / "QC/MULTIQC/Raw_fastq.html")
        elif mode == "multiqc_trimmed":
            res.append(base / "QC/MULTIQC//Trimmed_fastq.html")
        elif mode == "multiqc_bam":
            res.append(base / "QC/MULTIQC/Bam_report.html")
        elif mode == "cutadapt":
            for sample in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "TRIMMED" / Path(sample["R1"]).name)
                if sample["R2"]:
                    res.append(base / "TRIMMED" / Path(sample["R2"]).name)
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for inp in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                    if sample["R1"]:
                        res.append(base / "TRIMMED" / Path(inp["R1"]).name)
                    if sample["R2"]:
                        res.append(base / "TRIMMED" / Path(inp["R2"]).name)
        elif mode == "fastqc_trimmed":
            for sample in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                if sample["R1"]:
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R1"]).name))
                if sample["R2"]:
                    res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample["R2"]).name))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for inp in cfg["SEQUENCINGS"][sequencing_name].get("SAMPLES", {}).values():
                    if sample["R1"]:
                        res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R1"]).name))
                    if sample["R2"]:
                        res.append(base / "QC/FASTQC/TRIMMED" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(inp["R2"]).name))
        elif mode == "bam":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + ".bam"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["INPUT"].keys():
                    res.append(base / "BAM" / (sample_name + ".bam"))
        elif mode == "bam_filtered_coord":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + "_filtered.coordsort.bam"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "BAM" / (sample_name + "_filtered.coordsort.bam"))
        elif mode == "bam_filtered_name":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BAM" / (sample_name + "_filtered.namesort.bam"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "BAM" / (sample_name + "_filtered.namesort.bam"))
        elif mode == "flagstat":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "QC/flagstat" / (sample_name + "_flagstat.txt"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "QC/flagstat" / (sample_name + "_flagstat.txt"))
        elif mode == "stats":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "QC/stats" / (sample_name + "_stats.txt"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "QC/stats" / (sample_name + "_stats.txt"))
        elif mode == "bed":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BED" / (sample_name + ".bed"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["INPUT"].keys():
                    res.append(base / "BED" / (sample_name + ".bed"))
        elif mode == "bed_sorted":
            for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                res.append(base / "BED" / (sample_name + "_sorted.bed"))
            if "INPUT" in cfg["SEQUENCINGS"][sequencing_name]:
                for sample_name in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].keys():
                    res.append(base / "BED" / (sample_name + "_sorted.bed"))
    else:
        print(f"There is an error, the configuration file don't contains a {sequencing_name} project!")
    return res


def get_project_paths_for_macs(cfg: dict,
                                project_name: str,
                                mode: str
                                ):
    """
    Get the files necessary for the macs2/macs3 rules of a project.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    project_name: str
        String representing the name of the project in cfg
    
    mode: str
        String indicating the output. Accepted values are:
            - macs (dict with all inputs and the outputs of the macs3 command for all samples associated with the project)
            - macs_output (list of all outputs of the macs3 command for the project)
    Returns
    -------
    :
        A dictionary of all file paths for the project.
    """
    
    # Basic checks of the configuration file
    if project_name not in cfg["PROJECTS"]:
        raise RuntimeError(f"The project {project_name} is not in the configuration file")
    if "TYPE" not in cfg["PROJECTS"][project_name] or cfg["PROJECTS"][project_name]["TYPE"] not in ["ATAC", "H3K27AC", "H3K27ME3", "H2AUB"]:
        raise RuntimeError(f"The project {project_name} don't list a valid 'TYPE'. Please add one among: ATAC, H3K27AC, H3K27ME3, H2AUB.")
    if "SEQUENCINGS" not in cfg["PROJECTS"][project_name] or len(cfg["PROJECTS"][project_name]["SEQUENCINGS"]) < 1:
        raise RuntimeError(f"The project {project_name} don't indicate any valid sequencing. Please add a sequencing or remove this project.")
    
    if mode == "macs":
        res={}
        for sequencing_name in cfg["PROJECTS"][project_name]["SEQUENCINGS"]:
            if sequencing_name not in cfg["SEQUENCINGS"]:
                raise RuntimeError(f"The project {project_name} list the sequencing {sequencing_name} who is not present in the configuration file.")
            if cfg["PROJECTS"][project_name]["TYPE"] in ["H3K27AC", "H3K27ME3", "H2AUB"]:
                # ChIP-seq samples need an input when identifying the peaks
                if "INPUT" not in cfg["SEQUENCINGS"][sequencing_name] or len(cfg["SEQUENCINGS"][sequencing_name]["INPUT"]) < 1:
                    raise RuntimeError(f"The type of the project {project_name} necessite an input for the callpeak command of macs but the associated {sequencing_name} don't list any.")
                path_input_bed = str(Path( cfg["SEQUENCINGS"][sequencing_name]["PATH"]) / "BED" / (list(cfg["SEQUENCINGS"][sequencing_name]["INPUT"].keys())[0] + "_sorted.bed"))
                for sample_name, sample_data in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].items():
                    if sample_data["TYPE"] == cfg["PROJECTS"][project_name]["TYPE"]:
                        res["_".join([sequencing_name, sample_name])]={
                            "INPUT": path_input_bed,
                            "SAMPLE": str(Path( cfg["SEQUENCINGS"][sequencing_name]["PATH"]) / "BED" / (sample_name + "_sorted.bed")),
                            "OUTDIR": str(Path(cfg["PROJECTS"][project_name]["PROJECT_PATH"]) / "peaks/"),
                            "NAME": "_".join(["peak_calling",project_name, sequencing_name, sample_name])
                            }
            else:
                # For the ATAC-seq, we don't need input file when identifying the peaks
                for sample_name, sample_data in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].items():
                    if sample_data["TYPE"] == cfg["PROJECTS"][project_name]["TYPE"]:
                        res["_".join([sequencing_name, sample_name])]={
                            "SAMPLE": str(Path( cfg["SEQUENCINGS"][sequencing_name]["PATH"]) / "BED" / (sample_name + "_sorted.bed")),
                            "OUTDIR": str(Path(cfg["PROJECTS"][project_name]["PROJECT_PATH"]) / "peaks/"),
                            "NAME": "_".join(["peak_calling",project_name, sequencing_name, sample_name])
                            }
        if len(res) < 1:
            raise RuntimeError(f"No sample corresponding to the {project_name} project were found! Please check your configuration file")
        return res
    
    elif mode == "macs_output":
        res=[]
        for sequencing_name in cfg["PROJECTS"][project_name]["SEQUENCINGS"]:
            if sequencing_name not in cfg["SEQUENCINGS"]:
                raise RuntimeError(f"The project {project_name} list the sequencing {sequencing_name} who is not present in the configuration file.")
            if cfg["PROJECTS"][project_name]["TYPE"] in ["H3K27AC", "H3K27ME3", "H2AUB"]:
                # ChIP-seq samples need an input when identifying the peaks
                if "INPUT" not in cfg["SEQUENCINGS"][sequencing_name] or len(cfg["SEQUENCINGS"][sequencing_name]["INPUT"]) < 1:
                    raise RuntimeError(f"The type of the project {project_name} necessite an input for the callpeak command of macs but the associated {sequencing_name} don't list any.")
                for sample_name, sample_data in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].items():
                    if sample_data["TYPE"] == cfg["PROJECTS"][project_name]["TYPE"]:
                        if cfg["PROJECTS"][project_name]["TYPE"] == "H3K27AC":
                            res.append(str(Path(cfg["PROJECTS"][project_name]["PROJECT_PATH"]) / f"peaks/macs3_{project_name}_{sequencing_name}_{sample_name}_peaks.narrowPeak"))
                        else:
                            res.append(str(Path(cfg["PROJECTS"][project_name]["PROJECT_PATH"]) / f"peaks/macs3_{project_name}_{sequencing_name}_{sample_name}_peaks.broadPeak"))
            else:
                # For the ATAC-seq, we don't need input file when identifying the peaks
                for sample_name, sample_data in cfg["SEQUENCINGS"][sequencing_name]["SAMPLES"].items():
                    if sample_data["TYPE"] == cfg["PROJECTS"][project_name]["TYPE"]:
                        res.append(str(Path(cfg["PROJECTS"][project_name]["PROJECT_PATH"]) / f"peaks/macs3_{project_name}_{sequencing_name}_{sample_name}_peaks.broadPeak"))
        if len(res) < 1:
            print(f"No sample corresponding to the {project_name} project were found! Please check your configuration file.")
        return res
    

def get_all_project_peaks(cfg: dict):
    """
    Get the files necessary for the macs3 rules of all projects.

    Parameters
    ----------
    cfg : dict
        Dict representing the configuration of an analysis with the chromake pipeline.
    
    Returns
    -------
    :
        A list of files outputed by macs2 or macs3
    """
    res = []
    if "PROJECTS" in cfg:
        for project_name in cfg["PROJECTS"].keys():
            res.extend(get_project_paths_for_macs(cfg, project_name, "macs_output"))
    return res
    
    



