import yaml
from pathlib import Path
from genomake.pipelines.chromake.scripts import paths as chr_paths
import re

onstart:
    if "SEQUENCING" not in config:
        raise RuntimeError("The configuration file is missing the 'SEQUENCING' field!")
    if "PROJECTS" not in config:
        raise RuntimeError("The configuration file is missing the 'PROJECTS' field!")
    if "executor" in config:
        print("EXECUTOR IS HERE!!!!")
    if "JOBS" not in config:
        print("Jobs field missing from the configuration file. Adding one with the example default value")
        config["JOBS"] = {
              "CORES_PER_JOBS": {
              "FASTQC": 10,
              "CUTADAPT": 10,
              "BOWTIE2": 30
              },
              "QOS_INFOS": {
                  "short": {"MaxWall": 2000},
                  "medium": {"MaxWall": 5000},
                  "long": {"MaxWall": 15000}
               }
        }
    else:
        if "CORES_PER_JOBS" not in config["JOBS"]:
            print("Number of cores to use for the jobs is not indicated in the config file. Using default values")
            config["JOBS"]["CORES_PER_JOBS"] = {
                "FASTQC": 10,
                "CUTADAPT": 10,
                "BOWTIE2": 30
            }
        else:
            if "FASTQC" not in config["JOBS"]["CORES_PER_JOBS"]:
                print("Number of cores not indicated for fastqc, defaulting to 10")
                config["JOBS"]["CORES_PER_JOBS"]["FASTQC"] = 10
            if "CUTADAPT" not in config["JOBS"]["CORES_PER_JOBS"]:
                print("Number of cores not indicated for cutadapt, defaulting to 10")
                config["JOBS"]["CORES_PER_JOBS"]["CUTADAPT"] = 10
            if "BOWTIE2" not in config["JOBS"]["CORES_PER_JOBS"]:
                print("Number of cores not indicated for bowtie2, defaulting to 30")
                config["JOBS"]["CORES_PER_JOBS"]["BOWTIE2"] = 30
        if "QOS_INFOS" not in config["JOBS"]:
            print("The 'QOS_INFOS' field is missing in the config file. Using the example default values to be abble to set the ressources field of the rules. Will be ignored if executor is not set.")
            config["JOBS"]["QOS_INFOS"] = {
                "short": {"MaxWall": 2000},
                "medium": {"MaxWall": 5000},
                "long": {"MaxWall": 15000}
            }
        
    for sequencing_name, sequencing_data in config["SEQUENCING"].items():
        if "INPUT" in sequencing_data and len(sequencing_data["INPUT"]) >= 2:
            print(f"THe {sequencing_name} sequencing list more than one input. All of them will be sequencded but only the first one '{list(sequencing_data["INPUT"].keys())[0]}' will be used for the samples pak calling.")
        
        if "PARAMETERS" not in sequencing_data:
            print(f"""
            The 'PARAMETERS' field is missing for the {sequencing_name} sequencing. Using the pipeline default. If you wish to not use those parameters, please set an empty string for the values:
            - CUTADAPT: -q --pair-filter=any
            
            """)
            config["SEQUENCING"][sequencing_name]["PARAMETERS"] = {
                "CUTADAPT": "-q 20 --pair-filter=any"
            }
        else:
            if "CUTADAPT" not in config["SEQUENCING"][sequencing_name]["PARAMETERS"]:
                print(f"The {sequencing_name} seqencing don't list parameters for cutadapt. Using the pipeline default: '-q 20 --pair-filter=any'")
                config["SEQUENCING"][sequencing_name]["PARAMETERS"]["CUTADAPT"] = ""
            
            
        sample_path = Path(sequencing_data["PATH"])
        if not sample_path.exists():
            raise RuntimeError(f"The sequencing {str(sequencing_name)} PATH field is not valid. Please check your config file!")
        (sample_path / "QC/FASTQC/RAW").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/FASTQC/TRIMMED").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/MULTIQC/RAW").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/MULTIQC/TRIMMED").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/CUTADAPT").mkdir(parents=True, exist_ok=True)
        (sample_path / "TRIMMED").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/BOWTIE2").mkdir(parents=True, exist_ok=True)
        (sample_path / "QC/PICARD").mkdir(parents=True, exist_ok=True)
        (sample_path / "SAM/fragmentLen").mkdir(parents=True, exist_ok=True)
        (sample_path / "BAM").mkdir(parents=True, exist_ok=True)
    for project_name, project_data in config["PROJECTS"].items():
        if "PROJECT_PATH" not in project_data:
            raise RuntimeError(f"The project {project_name} is missing the 'PROJECT_PATH field! Please add a valid path.")
        elif project_data["PROJECT_PATH"] == "":
            raise RuntimeError(f"The project {project_name} 'PROJECT_PATH field is empty! Please add a valid path.")
        else:
            Path(project_data["PROJECT_PATH"]).mkdir(parents=True, exist_ok=True)


rule all:
    input:
        *chr_paths.get_all_fastq_related_paths(config, "fastqc_raw"),
        *chr_paths.get_all_fastq_related_paths(config, "multiqc_raw"),
        *chr_paths.get_all_fastq_related_paths(config, "cutadapt"),
        *chr_paths.get_all_fastq_related_paths(config, "fastqc_trimmed"),
        *chr_paths.get_all_fastq_related_paths(config, "multiqc_trimmed"),
        *chr_paths.get_all_fastq_related_paths(config, "bam"),

def get_qos_from_time(attempt: int, default_time_min: int)->str:

    if "JOBS" not in config or "QOS_INFOS" not in config["JOBS"]:
        return "long"

    runtime_minutes = attempt * default_time_min
    suitable_qos = None

    for qos_name, qos_info in config["JOBS"]["QOS_INFOS"].items():
        maxwall = qos_info.get("MaxWall")
        if maxwall is None:
            continue
        if maxwall >= runtime_minutes:
            if suitable_qos is None or maxwall < config["JOBS"]["QOS_INFOS"][suitable_qos]["MaxWall"]:
                suitable_qos = qos_name

    # fallback to 'long' if none found
    return suitable_qos or "long"


for sequencing_name, sequencing_data in config["SEQUENCING"].items():
    rule:
        name:
            f"fastqc_raw_{sequencing_name}"
        input:
            *chr_paths.get_sequencing_fastq_related_paths(config, sequencing_name, "fastq_raw"),
        output:
            *chr_paths.get_sequencing_fastq_related_paths(config, sequencing_name, "fastqc_raw"),
            *chr_paths.get_sequencing_fastq_related_paths(config, sequencing_name, "multiqc_raw"),
        params:
            fastqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/FASTQC/RAW/"),
            multiqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/MULTIQC/RAW/"),
        
        threads: config["JOBS"]["CORES_PER_JOBS"]["FASTQC"]

        resources:
            mem_mb=lambda wildcards, attempt: 20000 * attempt,
            runtime=lambda wildcards, attempt: attempt * 60,
            qos=lambda wildcards, attempt: get_qos_from_time(attempt, 60),
        shell:
            r"""
            fastqc \
                {input} \
                -t {threads} \
                -o {params.fastqc_outdir}
            multiqc \
                {params.fastqc_outdir} \
                -o {params.multiqc_outdir}
            """
    
    
    if (
        "R1_ADAPTOR" in sequencing_data
        and "R2_ADAPTOR" in sequencing_data
        and sequencing_data["R1_ADAPTOR"] != ''
        and sequencing_data["R2_ADAPTOR"] != ''
    ):
        for sample_name, sample_data in sequencing_data["SAMPLES"].items():
            rule:
                name:
                    f"cutadapt_{sequencing_name}_{sample_name}"
                input:
                    str(Path(sequencing_data["PATH"]) / sample_data["R1"]),
                    str(Path(sequencing_data["PATH"]) / sample_data["R2"]),
                output:
                    str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(sample_data["R1"]).name),
                    str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(sample_data["R2"]).name),
                    str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample_data["R1"]).name)),
                    str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(sample_data["R2"]).name)),
                threads:
                    config["JOBS"]["CORES_PER_JOBS"]["CUTADAPT"]

                params:
                    r1_adaptor=sequencing_data["R1_ADAPTOR"],
                    r2_adaptor=sequencing_data["R2_ADAPTOR"],
                    cutadapt_options=sequencing_data["PARAMETERS"]["CUTADAPT"],
                    cutadapt_log=str(Path(sequencing_data["PATH"]) / "QC/CUTADAPT/" / sample_name) + ".txt",
                    fastqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/"),
                resources:
                    mem_mb=lambda wildcards, attempt: 2000 * attempt,
                    runtime=lambda wildcards, attempt: attempt * 60,
                    qos=lambda wildcards, attempt: get_qos_from_time(attempt, 60),
                shell:
                    r"""
                    cutadapt -a {params.r1_adaptor} -A {params.r2_adaptor} \
                        -o {output[0]} -p {output[1]} \
                        {params.cutadapt_options} -j {threads} \
                        {input[0]} {input[1]} > {params.cutadapt_log}
                    fastqc \
                        {output[0]} {output[1]} \
                        -t {threads} \
                        -o {params.fastqc_outdir}
                    """
            
            if "PARAMETERS" in sequencing_data and "BOWTIE2_REF" in sequencing_data["PARAMETERS"]:
                rule:
                    name:
                        f"bowtie2_{sequencing_name}_{sample_name}"
                    input:
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(sample_data["R1"]).name),
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(sample_data["R2"]).name),
                    output:
                        str(Path(sequencing_data["PATH"]) / "SAM/fragmentLen" / (sample_name + "_fragmentLen.txt")),
                        str(Path(sequencing_data["PATH"]) / "SAM/" / (sample_name + "_sorted.sam")),
                        str(Path(sequencing_data["PATH"]) / "SAM/" / (sample_name + "_rmDup.sam")),
                        str(Path(sequencing_data["PATH"]) / "BAM/" / (sample_name + ".bam")),
                    threads:
                        config["JOBS"]["CORES_PER_JOBS"]["BOWTIE2"]
                    params:
                        bowtie_ref=sequencing_data["PARAMETERS"]["BOWTIE2_REF"],
                        bowtie_log=str(Path(sequencing_data["PATH"]) / "QC/BOWTIE2/" / (sample_name + ".log")),
                        sam_output=str(Path(sequencing_data["PATH"]) / "SAM/" / (sample_name + ".sam")),
                        picard_log=str(Path(sequencing_data["PATH"]) / "QC/PICARD/" / (sample_name + "_picard.rmDup.txt")),
                    resources:
                        mem_mb=lambda wildcards, attempt: 10000 * attempt,
                        runtime=lambda wildcards, attempt: attempt * 180,
                        qos=lambda wildcards, attempt: get_qos_from_time(attempt, 180),
                shell:
                    r"""
                    bowtie2 -p {threads} --local --very-sensitive-local \
                    --no-mixed --no-discordant --phred33 -I 10 -X 700 \
                        -x "{params.bowtie_ref}" -1 {input[0]} -2 {input[1]} \
                        -S {params.sam_output} &> {params.bowtie_log}
                    
                    samtools view -F 0x04 {params.sam_output} | \
                      awk -F'\t' 'function abs(x){return ((x < 0.0) ? -x : x)} {print abs($9)}' | \
                      sort | uniq -c | \
                      awk -v OFS="\t" '{print $2, $1/2}' > {output[0]}
                      
                    picard SortSam -I {params.sam_output} -o {output[1]} -SORT_ORDER coordinate
                    picard MarkDuplicate -I {output[1]} -o {output[2]} -REMOVE_DUPLICATES=true \
                      -METRICS_FILE {params.picard_log}
                      
                    samtools view -bS -F 0x04 {output[2]} -o {output[3]}
                    """
                        
        if "INPUT" in sequencing_data.keys():        
            for input_name, input_data in sequencing_data["INPUT"].items():
                rule:
                    name:
                        f"cutadapt_{sequencing_name}_{input_name}"
                    input:
                        str(Path(sequencing_data["PATH"]) / input_data["R1"]),
                        str(Path(sequencing_data["PATH"]) / input_data["R2"]),
                    output:
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(input_data["R1"]).name),
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(input_data["R2"]).name),
                        str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(input_data["R1"]).name)),
                        str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/" / re.sub(r"\.fastq(\.gz)?$", "_fastqc.html", Path(input_data["R2"]).name)),
                    threads:
                        config["JOBS"]["CORES_PER_JOBS"]["CUTADAPT"]
                    params:
                        r1_adaptor=sequencing_data["R1_ADAPTOR"],
                        r2_adaptor=sequencing_data["R2_ADAPTOR"],
                        cutadapt_options=sequencing_data["PARAMETERS"]["CUTADAPT"],
                        cutadapt_log=str(Path(sequencing_data["PATH"]) / "QC/CUTADAPT/" / input_name) + ".txt",
                        fastqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/"),
                    resources:
                        mem_mb=lambda wildcards, attempt: 2000 * attempt,
                        runtime=lambda wildcards, attempt: attempt * 60,
                        qos=lambda wildcards, attempt: get_qos_from_time(attempt, 60),
                    shell:
                        r"""
                        cutadapt -a {params.r1_adaptor} -A {params.r2_adaptor} \
                            -o {output[0]} -p {output[1]} \
                            {params.cutadapt_options} -j {threads} \
                            {input[0]} {input[1]} > {params.cutadapt_log}
                        fastqc \
                            {output[0]} {output[1]} \
                            -t {threads} \
                            -o {params.fastqc_outdir}
                        """
                
            if "PARAMETERS" in sequencing_data and "BOWTIE2_REF" in sequencing_data["PARAMETERS"]:
                rule:
                    name:
                        f"bowtie2_{sequencing_name}_{input_name}"
                    input:
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(input_data["R1"]).name),
                        str(Path(sequencing_data["PATH"]) / "TRIMMED/" / Path(input_data["R2"]).name),
                    output:
                        str(Path(sequencing_data["PATH"]) / "SAM/fragmentLen" / (input_name + "_fragmentLen.txt")),
                        str(Path(sequencing_data["PATH"]) / "SAM/" / (input_name + "_sorted.sam")),
                        str(Path(sequencing_data["PATH"]) / "SAM/" / (input_name + "_rmDup.sam")),
                        str(Path(sequencing_data["PATH"]) / "BAM/" / (input_name + ".bam")),
                    threads:
                        config["JOBS"]["CORES_PER_JOBS"]["BOWTIE2"]
                    params:
                        bowtie_ref=sequencing_data["PARAMETERS"]["BOWTIE2_REF"],
                        bowtie_log=str(Path(sequencing_data["PATH"]) / "QC/BOWTIE2/" / (input_name + ".log")),
                        sam_output=str(Path(sequencing_data["PATH"]) / "SAM/" / (input_name + ".sam")),
                        picard_log=str(Path(sequencing_data["PATH"]) / "QC/PICARD/" / (input_name + "_picard.rmDup.txt")),
                    resources:
                        mem_mb=lambda wildcards, attempt: 10000 * attempt,
                        runtime=lambda wildcards, attempt: attempt * 180,
                        qos=lambda wildcards, attempt: get_qos_from_time(attempt, 180),
                    shell:
                        r"""
                        bowtie2 -p {threads} --local --very-sensitive-local \
                        --no-mixed --no-discordant --phred33 -I 10 -X 700 \
                            -x "{params.bowtie_ref}" -1 {input[0]} -2 {input[1]} \
                            -S {params.sam_output} &> {params.bowtie_log}
                        
                        samtools view -F 0x04 {params.sam_output} | \
                          awk -F'\t' 'function abs(x){return ((x < 0.0) ? -x : x)} {print abs($9)}' | \
                          sort | uniq -c | \
                          awk -v OFS="\t" '{print $2, $1/2}' > {output[0]}
                          
                        picard SortSam -I {params.sam_output} -o {output[1]} -SORT_ORDER coordinate
                        picard MarkDuplicate -I {output[1]} -o {output[2]} -REMOVE_DUPLICATES=true \
                          -METRICS_FILE {params.picard_log}
                          
                        samtools view -bS -F 0x04 {output[2]} -o {output[3]}
                        """
        
        rule:
            name:
                f"multiqc_trimmed_{sequencing_name}"
            input:
                *chr_paths.get_sequencing_fastq_related_paths(config, sequencing_name, "fastqc_trimmed"),
            output:
                *chr_paths.get_sequencing_fastq_related_paths(config, sequencing_name, "multiqc_trimmed"),
            threads:
                1,
            params:
                fastqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/FASTQC/TRIMMED/"),
                multiqc_outdir=str(Path(sequencing_data["PATH"]) / "QC/MULTIQC/TRIMMED/"),
            resources:
                mem_mb=lambda wildcards, attempt: 20000 * attempt,
                runtime=lambda wildcards, attempt: attempt * 60,
                qos=lambda wildcards, attempt: get_qos_from_time(attempt, 60),
            shell:
                r"""
                multiqc \
                    {params.fastqc_outdir} \
                    -o {params.multiqc_outdir}
                """
                
    #else:
        # If there no adaptor for trimming we use BWA on the original fastq (samples and input) do add later (same rules but not trimming)
        